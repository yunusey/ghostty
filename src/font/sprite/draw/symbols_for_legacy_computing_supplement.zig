//! Symbols for Legacy Computing Supplement | U+1CC00...U+1CEBF
//! https://en.wikipedia.org/wiki/Symbols_for_Legacy_Computing_Supplement
//!
//! ğœ°€ ğœ° ğœ°‚ ğœ°ƒ ğœ°„ ğœ°… ğœ°† ğœ°‡ ğœ°ˆ ğœ°‰ ğœ°Š ğœ°‹ ğœ°Œ ğœ° ğœ° ğœ°
//! ğœ° ğœ°‘ ğœ°’ ğœ°“ ğœ°” ğœ°• ğœ°– ğœ°— ğœ°˜ ğœ°™ ğœ°š ğœ°› ğœ°œ ğœ° ğœ° ğœ°Ÿ
//! ğœ°  ğœ°¡ ğœ°¢ ğœ°£ ğœ°¤ ğœ°¥ ğœ°¦ ğœ°§ ğœ°¨ ğœ°© ğœ°ª ğœ°« ğœ°¬ ğœ°­ ğœ°® ğœ°¯
//! ğœ°° ğœ°± ğœ°² ğœ°³ ğœ°´ ğœ°µ ğœ°¶ ğœ°· ğœ°¸ ğœ°¹ ğœ°º ğœ°» ğœ°¼ ğœ°½ ğœ°¾ ğœ°¿
//! ğœ±€ ğœ± ğœ±‚ ğœ±ƒ ğœ±„ ğœ±… ğœ±† ğœ±‡ ğœ±ˆ ğœ±‰ ğœ±Š ğœ±‹ ğœ±Œ ğœ± ğœ± ğœ±
//! ğœ± ğœ±‘ ğœ±’ ğœ±“ ğœ±” ğœ±• ğœ±– ğœ±— ğœ±˜ ğœ±™ ğœ±š ğœ±› ğœ±œ ğœ± ğœ± ğœ±Ÿ
//! ğœ±  ğœ±¡ ğœ±¢ ğœ±£ ğœ±¤ ğœ±¥ ğœ±¦ ğœ±§ ğœ±¨ ğœ±© ğœ±ª ğœ±« ğœ±¬ ğœ±­ ğœ±® ğœ±¯
//! ğœ±° ğœ±± ğœ±² ğœ±³ ğœ±´ ğœ±µ ğœ±¶ ğœ±· ğœ±¸ ğœ±¹ ğœ±º ğœ±» ğœ±¼ ğœ±½ ğœ±¾ ğœ±¿
//! ğœ²€ ğœ² ğœ²‚ ğœ²ƒ ğœ²„ ğœ²… ğœ²† ğœ²‡ ğœ²ˆ ğœ²‰ ğœ²Š ğœ²‹ ğœ²Œ ğœ² ğœ² ğœ²
//! ğœ² ğœ²‘ ğœ²’ ğœ²“ ğœ²” ğœ²• ğœ²– ğœ²— ğœ²˜ ğœ²™ ğœ²š ğœ²› ğœ²œ ğœ² ğœ² ğœ²Ÿ
//! ğœ²  ğœ²¡ ğœ²¢ ğœ²£ ğœ²¤ ğœ²¥ ğœ²¦ ğœ²§ ğœ²¨ ğœ²© ğœ²ª ğœ²« ğœ²¬ ğœ²­ ğœ²® ğœ²¯
//! ğœ²° ğœ²± ğœ²² ğœ²³ ğœ²´ ğœ²µ ğœ²¶ ğœ²· ğœ²¸ ğœ²¹ ğœ²º ğœ²» ğœ²¼ ğœ²½ ğœ²¾ ğœ²¿
//! ğœ³€ ğœ³ ğœ³‚ ğœ³ƒ ğœ³„ ğœ³… ğœ³† ğœ³‡ ğœ³ˆ ğœ³‰ ğœ³Š ğœ³‹ ğœ³Œ ğœ³ ğœ³ ğœ³
//! ğœ³ ğœ³‘ ğœ³’ ğœ³“ ğœ³” ğœ³• ğœ³– ğœ³— ğœ³˜ ğœ³™ ğœ³š ğœ³› ğœ³œ ğœ³ ğœ³ ğœ³Ÿ
//! ğœ³  ğœ³¡ ğœ³¢ ğœ³£ ğœ³¤ ğœ³¥ ğœ³¦ ğœ³§ ğœ³¨ ğœ³© ğœ³ª ğœ³« ğœ³¬ ğœ³­ ğœ³® ğœ³¯
//! ğœ³° ğœ³± ğœ³² ğœ³³ ğœ³´ ğœ³µ ğœ³¶ ğœ³· ğœ³¸ ğœ³¹
//! ğœ´€ ğœ´ ğœ´‚ ğœ´ƒ ğœ´„ ğœ´… ğœ´† ğœ´‡ ğœ´ˆ ğœ´‰ ğœ´Š ğœ´‹ ğœ´Œ ğœ´ ğœ´ ğœ´
//! ğœ´ ğœ´‘ ğœ´’ ğœ´“ ğœ´” ğœ´• ğœ´– ğœ´— ğœ´˜ ğœ´™ ğœ´š ğœ´› ğœ´œ ğœ´ ğœ´ ğœ´Ÿ
//! ğœ´  ğœ´¡ ğœ´¢ ğœ´£ ğœ´¤ ğœ´¥ ğœ´¦ ğœ´§ ğœ´¨ ğœ´© ğœ´ª ğœ´« ğœ´¬ ğœ´­ ğœ´® ğœ´¯
//! ğœ´° ğœ´± ğœ´² ğœ´³ ğœ´´ ğœ´µ ğœ´¶ ğœ´· ğœ´¸ ğœ´¹ ğœ´º ğœ´» ğœ´¼ ğœ´½ ğœ´¾ ğœ´¿
//! ğœµ€ ğœµ ğœµ‚ ğœµƒ ğœµ„ ğœµ… ğœµ† ğœµ‡ ğœµˆ ğœµ‰ ğœµŠ ğœµ‹ ğœµŒ ğœµ ğœµ ğœµ
//! ğœµ ğœµ‘ ğœµ’ ğœµ“ ğœµ” ğœµ• ğœµ– ğœµ— ğœµ˜ ğœµ™ ğœµš ğœµ› ğœµœ ğœµ ğœµ ğœµŸ
//! ğœµ  ğœµ¡ ğœµ¢ ğœµ£ ğœµ¤ ğœµ¥ ğœµ¦ ğœµ§ ğœµ¨ ğœµ© ğœµª ğœµ« ğœµ¬ ğœµ­ ğœµ® ğœµ¯
//! ğœµ° ğœµ± ğœµ² ğœµ³ ğœµ´ ğœµµ ğœµ¶ ğœµ· ğœµ¸ ğœµ¹ ğœµº ğœµ» ğœµ¼ ğœµ½ ğœµ¾ ğœµ¿
//! ğœ¶€ ğœ¶ ğœ¶‚ ğœ¶ƒ ğœ¶„ ğœ¶… ğœ¶† ğœ¶‡ ğœ¶ˆ ğœ¶‰ ğœ¶Š ğœ¶‹ ğœ¶Œ ğœ¶ ğœ¶ ğœ¶
//! ğœ¶ ğœ¶‘ ğœ¶’ ğœ¶“ ğœ¶” ğœ¶• ğœ¶– ğœ¶— ğœ¶˜ ğœ¶™ ğœ¶š ğœ¶› ğœ¶œ ğœ¶ ğœ¶ ğœ¶Ÿ
//! ğœ¶  ğœ¶¡ ğœ¶¢ ğœ¶£ ğœ¶¤ ğœ¶¥ ğœ¶¦ ğœ¶§ ğœ¶¨ ğœ¶© ğœ¶ª ğœ¶« ğœ¶¬ ğœ¶­ ğœ¶® ğœ¶¯
//! ğœ¶° ğœ¶± ğœ¶² ğœ¶³ ğœ¶´ ğœ¶µ ğœ¶¶ ğœ¶· ğœ¶¸ ğœ¶¹ ğœ¶º ğœ¶» ğœ¶¼ ğœ¶½ ğœ¶¾ ğœ¶¿
//! ğœ·€ ğœ· ğœ·‚ ğœ·ƒ ğœ·„ ğœ·… ğœ·† ğœ·‡ ğœ·ˆ ğœ·‰ ğœ·Š ğœ·‹ ğœ·Œ ğœ· ğœ· ğœ·
//! ğœ· ğœ·‘ ğœ·’ ğœ·“ ğœ·” ğœ·• ğœ·– ğœ·— ğœ·˜ ğœ·™ ğœ·š ğœ·› ğœ·œ ğœ· ğœ· ğœ·Ÿ
//! ğœ·  ğœ·¡ ğœ·¢ ğœ·£ ğœ·¤ ğœ·¥ ğœ·¦ ğœ·§ ğœ·¨ ğœ·© ğœ·ª ğœ·« ğœ·¬ ğœ·­ ğœ·® ğœ·¯
//! ğœ·° ğœ·± ğœ·² ğœ·³ ğœ·´ ğœ·µ ğœ·¶ ğœ·· ğœ·¸ ğœ·¹ ğœ·º ğœ·» ğœ·¼ ğœ·½ ğœ·¾ ğœ·¿
//! ğœ¸€ ğœ¸ ğœ¸‚ ğœ¸ƒ ğœ¸„ ğœ¸… ğœ¸† ğœ¸‡ ğœ¸ˆ ğœ¸‰ ğœ¸Š ğœ¸‹ ğœ¸Œ ğœ¸ ğœ¸ ğœ¸
//! ğœ¸ ğœ¸‘ ğœ¸’ ğœ¸“ ğœ¸” ğœ¸• ğœ¸– ğœ¸— ğœ¸˜ ğœ¸™ ğœ¸š ğœ¸› ğœ¸œ ğœ¸ ğœ¸ ğœ¸Ÿ
//! ğœ¸  ğœ¸¡ ğœ¸¢ ğœ¸£ ğœ¸¤ ğœ¸¥ ğœ¸¦ ğœ¸§ ğœ¸¨ ğœ¸© ğœ¸ª ğœ¸« ğœ¸¬ ğœ¸­ ğœ¸® ğœ¸¯
//! ğœ¸° ğœ¸± ğœ¸² ğœ¸³ ğœ¸´ ğœ¸µ ğœ¸¶ ğœ¸· ğœ¸¸ ğœ¸¹ ğœ¸º ğœ¸» ğœ¸¼ ğœ¸½ ğœ¸¾ ğœ¸¿
//! ğœ¹€ ğœ¹ ğœ¹‚ ğœ¹ƒ ğœ¹„ ğœ¹… ğœ¹† ğœ¹‡ ğœ¹ˆ ğœ¹‰ ğœ¹Š ğœ¹‹ ğœ¹Œ ğœ¹ ğœ¹ ğœ¹
//! ğœ¹ ğœ¹‘ ğœ¹’ ğœ¹“ ğœ¹” ğœ¹• ğœ¹– ğœ¹— ğœ¹˜ ğœ¹™ ğœ¹š ğœ¹› ğœ¹œ ğœ¹ ğœ¹ ğœ¹Ÿ
//! ğœ¹  ğœ¹¡ ğœ¹¢ ğœ¹£ ğœ¹¤ ğœ¹¥ ğœ¹¦ ğœ¹§ ğœ¹¨ ğœ¹© ğœ¹ª ğœ¹« ğœ¹¬ ğœ¹­ ğœ¹® ğœ¹¯
//! ğœ¹° ğœ¹± ğœ¹² ğœ¹³ ğœ¹´ ğœ¹µ ğœ¹¶ ğœ¹· ğœ¹¸ ğœ¹¹ ğœ¹º ğœ¹» ğœ¹¼ ğœ¹½ ğœ¹¾ ğœ¹¿
//! ğœº€ ğœº ğœº‚ ğœºƒ ğœº„ ğœº… ğœº† ğœº‡ ğœºˆ ğœº‰ ğœºŠ ğœº‹ ğœºŒ ğœº ğœº ğœº
//! ğœº ğœº‘ ğœº’ ğœº“ ğœº” ğœº• ğœº– ğœº— ğœº˜ ğœº™ ğœºš ğœº› ğœºœ ğœº ğœº ğœºŸ
//! ğœº  ğœº¡ ğœº¢ ğœº£ ğœº¤ ğœº¥ ğœº¦ ğœº§ ğœº¨ ğœº© ğœºª ğœº« ğœº¬ ğœº­ ğœº® ğœº¯
//! ğœº° ğœº± ğœº² ğœº³
//!

const std = @import("std");
const Allocator = std.mem.Allocator;
const assert = std.debug.assert;

const z2d = @import("z2d");

const common = @import("common.zig");
const Thickness = common.Thickness;
const Corner = common.Corner;
const Shade = common.Shade;
const xHalfs = common.xHalfs;
const yQuads = common.yQuads;
const rect = common.rect;

const font = @import("../../main.zig");

const octant_min = 0x1cd00;
const octant_max = 0x1cde5;

/// Octants
pub fn draw1CD00_1CDE5(
    cp: u32,
    canvas: *font.sprite.Canvas,
    width: u32,
    height: u32,
    metrics: font.Metrics,
) !void {
    _ = width;
    _ = height;

    // Octant representation. We use the funny numeric string keys
    // so its easier to parse the actual name used in the Symbols for
    // Legacy Computing spec.
    const Octant = packed struct(u8) {
        @"1": bool = false,
        @"2": bool = false,
        @"3": bool = false,
        @"4": bool = false,
        @"5": bool = false,
        @"6": bool = false,
        @"7": bool = false,
        @"8": bool = false,
    };

    // Parse the octant data. This is all done at comptime so
    // that this is static data that is embedded in the binary.
    const octants_len = octant_max - octant_min + 1;
    const octants: [octants_len]Octant = comptime octants: {
        @setEvalBranchQuota(10_000);

        var result: [octants_len]Octant = @splat(.{});
        var i: usize = 0;

        const data = @embedFile("octants.txt");
        var it = std.mem.splitScalar(u8, data, '\n');
        while (it.next()) |line| {
            // Skip comments
            if (line.len == 0 or line[0] == '#') continue;

            const current = &result[i];
            i += 1;

            // Octants are in the format "BLOCK OCTANT-1235". The numbers
            // at the end are keys into our packed struct. Since we're
            // at comptime we can metaprogram it all.
            const idx = std.mem.indexOfScalar(u8, line, '-').?;
            for (line[idx + 1 ..]) |c| @field(current, &.{c}) = true;
        }

        assert(i == octants_len);
        break :octants result;
    };

    const x_halfs = xHalfs(metrics);
    const y_quads = yQuads(metrics);
    const oct = octants[cp - octant_min];
    if (oct.@"1") rect(metrics, canvas, 0, 0, x_halfs[0], y_quads[0]);
    if (oct.@"2") rect(metrics, canvas, x_halfs[1], 0, metrics.cell_width, y_quads[0]);
    if (oct.@"3") rect(metrics, canvas, 0, y_quads[1], x_halfs[0], y_quads[2]);
    if (oct.@"4") rect(metrics, canvas, x_halfs[1], y_quads[1], metrics.cell_width, y_quads[2]);
    if (oct.@"5") rect(metrics, canvas, 0, y_quads[3], x_halfs[0], y_quads[4]);
    if (oct.@"6") rect(metrics, canvas, x_halfs[1], y_quads[3], metrics.cell_width, y_quads[4]);
    if (oct.@"7") rect(metrics, canvas, 0, y_quads[5], x_halfs[0], metrics.cell_height);
    if (oct.@"8") rect(metrics, canvas, x_halfs[1], y_quads[5], metrics.cell_width, metrics.cell_height);
}

// Separated Block Quadrants
// ğœ°¡ ğœ°¢ ğœ°£ ğœ°¤ ğœ°¥ ğœ°¦ ğœ°§ ğœ°¨ ğœ°© ğœ°ª ğœ°« ğœ°¬ ğœ°­ ğœ°® ğœ°¯
pub fn draw1CC21_1CC2F(
    cp: u32,
    canvas: *font.sprite.Canvas,
    width: u32,
    height: u32,
    metrics: font.Metrics,
) !void {
    _ = metrics;

    // Struct laid out to match the codepoint order so we can cast from it.
    const Quads = packed struct(u4) {
        tl: bool,
        tr: bool,
        bl: bool,
        br: bool,
    };

    const quad: Quads = @bitCast(@as(u4, @truncate(cp - 0x1CC20)));

    const gap: i32 = @intCast(@max(1, width / 12));

    const mid_gap_x: i32 = gap * 2 + @as(i32, @intCast(width % 2));
    const mid_gap_y: i32 = gap * 2 + @as(i32, @intCast(height % 2));

    const w: i32 = @divExact(@as(i32, @intCast(width)) - gap * 2 - mid_gap_x, 2);
    const h: i32 = @divExact(@as(i32, @intCast(height)) - gap * 2 - mid_gap_y, 2);

    if (quad.tl) canvas.box(
        gap,
        gap,
        gap + w,
        gap + h,
        .on,
    );
    if (quad.tr) canvas.box(
        gap + w + mid_gap_x,
        gap,
        gap + w + mid_gap_x + w,
        gap + h,
        .on,
    );
    if (quad.bl) canvas.box(
        gap,
        gap + h + mid_gap_y,
        gap + w,
        gap + h + mid_gap_y + h,
        .on,
    );
    if (quad.br) canvas.box(
        gap + w + mid_gap_x,
        gap + h + mid_gap_y,
        gap + w + mid_gap_x + w,
        gap + h + mid_gap_y + h,
        .on,
    );
}
